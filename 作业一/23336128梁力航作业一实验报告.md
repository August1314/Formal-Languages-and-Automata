# 形式语言与自动机 - 第一次Python编程作业实验报告

**课程名称：** 形式语言与自动机  
**学生姓名：** [梁力航]  
**学生学号：** [23336128]  
**授课教师：** [冯剑琳]  
**中山大学**

---

## 问题描述

本实验实现形式语言与自动机课程的第一次Python编程作业，包含四道题目：

1. **语言串接**：实现两个语言的串接操作
2. **星操作**：实现上界为T的星操作
3. **DFA模拟**：实现确定性有限自动机的转移函数
4. **子集构造算法**：将NFA转换为等价的DFA

### 实验目标

通过本次实验：
1. 深入理解形式语言的基本操作（串接、星操作）
2. 掌握DFA和NFA的实现方法
3. 理解并实现子集构造算法
4. 提高Python编程能力和算法实现能力

---

## 项目结构

本项目采用模块化设计，创建了可复用的组件库：

```
作业一/
├── common/                    # 可复用组件包
│   ├── __init__.py           # 包初始化文件
│   ├── language.py           # Language类：语言操作
│   ├── dfa.py                # DFA类：确定性有限自动机
│   └── nfa.py                # NFA类：非确定性有限自动机
├── question1.py              # 第一题：语言串接
├── question2.py              # 第二题：星操作
├── question3.py              # 第三题：DFA模拟
├── question4.py              # 第四题：子集构造算法
├── README.md                 # 项目说明文档
└── 实验报告.md               # 本文件
```

### 设计理念

- **模块化**：将可复用的组件抽象为独立的类
- **可扩展性**：组件可在后续课程中继续使用
- **清晰性**：代码结构清晰，注释详细
- **标准化**：遵循Python编程规范

---

## 1. 第一题：语言串接

### 1.1 问题描述

实现两个语言的串接操作：

$$L_1L_2 = \{xy \mid x \in L_1 \text{ 且 } y \in L_2\}$$

**要求**：
- 每个语言至少包含3个字符串
- 打印出串接结果中的所有字符串

### 1.2 实现方案

#### 核心算法

```python
def concatenate(self, other):
    """语言串接操作"""
    result = set()
    for x in self.strings:
        for y in other.strings:
            result.add(x + y)
    return Language(result)
```

**算法复杂度**：
- 时间复杂度：O(|L1| × |L2|)
- 空间复杂度：O(|L1| × |L2|)

#### 测试用例

- **L1** = {"a", "ab", "abc"}
- **L2** = {"x", "xy", "xyz"}

### 1.3 运行结果

```
============================================================
第一题：语言串接
============================================================

L1 = {a, ab, abc}
L1包含 3 个字符串

L2 = {x, xy, xyz}
L2包含 3 个字符串

------------------------------------------------------------
计算串接 L1L2...
------------------------------------------------------------

L1L2 = {ax, abx, axy, abcx, abxy, axyz, abcxy, abxyz, abcxyz}
L1L2包含 9 个字符串

串接结果详细列表：
  1. ax
  2. abx
  3. axy
  4. abcx
  5. abxy
  6. axyz
  7. abcxy
  8. abxyz
  9. abcxyz
```

### 1.4 结果分析

✅ **正确性验证**：
- 结果包含9个字符串（3 × 3 = 9）
- 每个结果都是L1中某个字符串与L2中某个字符串的串接
- 所有可能的组合都已生成

✅ **完整性**：
- 覆盖了所有可能的串接组合
- 结果按长度和字典序排列，便于阅读

### 1.5 额外测试：包含空字符串的语言

为了测试更复杂的情况，我们增加了包含空字符串的测试：

**测试用例**：
- **L3** = {ε, "a", "b", "ab"}（包含空字符串）
- **L4** = {"0", "1", "01"}

**运行结果**：
```
L3L4 = {0, 1, 01, a0, a1, b0, b1, a01, ab0, ab1, b01, ab01}
L3L4包含 12 个字符串
```

**结果分析**：
- 总共12个字符串（4 × 3 = 12）✓
- 空字符串与任何字符串串接得到原字符串：ε + "0" = "0" ✓
- 验证了空字符串在串接操作中的单位元性质

**重要性质验证**：
- **单位元性质**：对于任何字符串s，ε·s = s·ε = s
- 从结果可以看到："0", "1", "01"都出现在结果中，正是ε与它们的串接

---

## 2. 第二题：星操作

### 2.1 问题描述

实现上界为T的星操作：

$$S_T(L) = \{w_1w_2 \cdots w_n \mid n \leq T, \text{每个 } w_i \in L\}$$

**要求**：
- 语言L至少包含2个字符串
- 上界T = 3
- 结果必须包含空字符串ε
- 打印出所有生成的字符串

### 2.2 实现方案

#### 核心算法

```python
def star(self, max_length):
    """上界为T的星操作"""
    result = {''}  # 初始化，包含空字符串
    current_level = {''}
    
    for i in range(max_length):
        next_level = set()
        for s in current_level:
            for w in self.strings:
                next_level.add(s + w)
        result.update(next_level)
        current_level = next_level
    
    return Language(result)
```

**算法说明**：
- 使用层次化生成方法
- 第i层生成长度为i的所有串接组合
- 时间复杂度：O(|L|^T)

#### 测试用例

- **L** = {"0", "1"}
- **T** = 3

### 2.3 运行结果

```
============================================================
第二题：上界为T的星操作
============================================================

L = {0, 1}
L包含 2 个字符串

上界 T = 3

------------------------------------------------------------
计算星操作 S_3(L)...
------------------------------------------------------------

S_3(L) = {ε, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, 101, 110, 111}
S_3(L)包含 15 个字符串

✓ 结果包含空字符串 ε

按长度分组的结果：
  长度 0: {ε} (1个)
  长度 1: {0, 1} (2个)
  长度 2: {00, 01, 10, 11} (4个)
  长度 3: {000, 001, 010, 011, 100, 101, 110, 111} (8个)
```

### 2.4 结果分析

✅ **正确性验证**：
- 总共15个字符串 = 1 + 2 + 4 + 8 = 2^0 + 2^1 + 2^2 + 2^3
- 符合公式：$\sum_{i=0}^{T} |L|^i = \sum_{i=0}^{3} 2^i = 15$

✅ **完整性检查**：
- 包含空字符串ε ✓
- 包含所有长度1的字符串（0, 1）✓
- 包含所有长度2的字符串（00, 01, 10, 11）✓
- 包含所有长度3的字符串（8个）✓

✅ **数学验证**：
- 对于|L| = 2, T = 3的情况
- 预期结果数量 = (2^(3+1) - 1) / (2 - 1) = 15 ✓

### 2.5 额外测试：更大的字母表

为了测试更复杂的情况，我们增加了更大字母表的测试：

**测试用例**：
- **L2** = {"a", "b", "c"}（3个字符）
- **T** = 2

**运行结果**：
```
S_2(L2) = {ε, a, b, c, aa, ab, ac, ba, bb, bc, ca, cb, cc}
S_2(L2)包含 13 个字符串

预期数量: 3^0 + 3^1 + 3^2 = 1 + 3 + 9 = 13
实际数量: 13
验证: ✓ 正确
```

**结果分析**：
- 长度0：1个（ε）
- 长度1：3个（a, b, c）
- 长度2：9个（aa, ab, ac, ba, bb, bc, ca, cb, cc）
- 总计：13个 = 3^0 + 3^1 + 3^2 ✓

**数学验证**：
- 对于|L| = n, T = k的情况
- 预期结果数量 = $\sum_{i=0}^{k} n^i = \frac{n^{k+1} - 1}{n - 1}$
- 本例：$\frac{3^3 - 1}{3 - 1} = \frac{27 - 1}{2} = 13$ ✓

**组合数学意义**：
- 长度为i的字符串有n^i个
- 这是一个等比数列求和问题
- 验证了星操作的组合性质

---

## 3. 第三题：DFA模拟

### 3.1 问题描述

实现课件中的DFA，该DFA接受不含两个连续1的所有0/1串。

**DFA定义**：
- **状态集合** Q = {A, B, C}
- **字母表** Σ = {0, 1}
- **起始状态** q₀ = A
- **接受状态** F = {A, B}
- **转移函数** δ：
  - δ(A, 0) = A
  - δ(A, 1) = B
  - δ(B, 0) = A
  - δ(B, 1) = C
  - δ(C, 0) = C
  - δ(C, 1) = C

**要求**：
- 实现转移函数delta(q, a)
- 实现扩展转移函数Edelta(q, s)
- Edelta通过调用delta实现
- 测试正例和负例字符串（各至少3个字符）
- 打印每一次状态转移

### 3.2 状态说明

- **状态A**：起始状态，上一个字符不是1（或刚开始）
- **状态B**：上一个字符是1
- **状态C**：陷阱状态，已经出现连续两个1

### 3.3 实现方案

#### 转移函数

```python
def delta(self, q, a):
    """单步转移函数 δ(q, a)"""
    if q not in self.states:
        raise ValueError(f"状态 {q} 不在状态集合中")
    if a not in self.alphabet:
        raise ValueError(f"字符 {a} 不在字母表中")
    if q not in self.transitions or a not in self.transitions[q]:
        raise ValueError(f"从状态 {q} 读入字符 {a} 的转移未定义")
    
    return self.transitions[q][a]
```

#### 扩展转移函数

```python
def extended_delta(self, q, s, verbose=False):
    """扩展转移函数 δ*(q, s)"""
    current_state = q
    
    if verbose:
        print(f"起始状态: {current_state}")
    
    for char in s:
        next_state = self.delta(current_state, char)
        if verbose:
            print(f"{current_state} --{char}--> {next_state}")
        current_state = next_state
    
    if verbose:
        print(f"最终状态: {current_state}")
    
    return current_state
```

### 3.4 测试用例

- **正例** Sp = "0101"（不含连续两个1）
- **负例** Sn = "011"（包含连续两个1）

### 3.5 运行结果

```
============================================================
第三题：DFA模拟
============================================================

DFA定义：
  状态集合 Q = {'C', 'B', 'A'}
  字母表 Σ = {'1', '0'}
  起始状态 q0 = A
  接受状态 F = {'B', 'A'}

  转移函数 δ:
    δ(A, 0) = A
    δ(A, 1) = B
    δ(B, 0) = A
    δ(B, 1) = C
    δ(C, 0) = C
    δ(C, 1) = C

============================================================
测试字符串
============================================================

正例字符串: "0101"
------------------------------------------------------------
起始状态: A
A --0--> A
A --1--> B
B --0--> A
A --1--> B
最终状态: B
结果: 接受 ✓
------------------------------------------------------------

负例字符串: "011"
------------------------------------------------------------
起始状态: A
A --0--> A
A --1--> B
B --1--> C
最终状态: C
结果: 拒绝 ✗
------------------------------------------------------------

============================================================
额外测试用例
============================================================
  "000" (全是0): 接受 ✓
  "010" (不含连续1): 接受 ✓
  "110" (开头就是连续1): 拒绝 ✗
  "0110" (中间有连续1): 拒绝 ✗
```

### 3.6 结果分析

✅ **正例验证**：
- "0101"：A→A→B→A→B，最终状态B ∈ F，接受 ✓
- "000"：A→A→A→A，最终状态A ∈ F，接受 ✓
- "010"：A→A→B→A，最终状态A ∈ F，接受 ✓

✅ **负例验证**：
- "011"：A→A→B→C，最终状态C ∉ F，拒绝 ✓
- "110"：A→B→C→C，最终状态C ∉ F，拒绝 ✓
- "0110"：A→A→B→C→C，最终状态C ∉ F，拒绝 ✓

✅ **DFA正确性**：
- 所有不含连续两个1的字符串都被接受
- 所有包含连续两个1的字符串都被拒绝
- 状态转移符合定义

---

## 4. 第四题：子集构造算法

### 4.1 问题描述

实现子集构造算法（Subset Construction），将NFA转换为等价的DFA。

**NFA定义**（基于课件lec2-nfa转移表）：
- **状态集合** Q = {1, 2, 3, 4, 5, 6, 7, 8, 9}
- **字母表** Σ = {r, b}
- **起始状态** q₀ = 1
- **接受状态** F = {9}
- **转移函数** δ（见下表）

| 状态 | r | b |
|------|---|---|
| 1 | {2, 4} | {5} |
| 2 | {4, 6} | {1, 3, 5} |
| 3 | {2, 6} | {5} |
| 4 | {2, 8} | {1, 5, 7} |
| 5 | {2, 4, 6, 8} | {1, 3, 7, 9} |
| 6 | {2, 8} | {3, 5, 9} |
| 7 | {4, 8} | {5} |
| 8 | {4, 6} | {5, 7, 9} |
| 9 | {6, 8} | {5} |

**要求**：
- 实现子集构造算法
- 打印生成的DFA转移表
- 标识起始状态和接受状态

### 4.2 子集构造算法原理

子集构造算法的核心思想：
1. DFA的每个状态对应NFA状态的一个子集
2. 从起始状态{q₀}开始
3. 对每个DFA状态和每个输入符号，计算NFA状态集合的转移
4. 重复直到没有新状态产生
5. 包含NFA接受状态的DFA状态为接受状态

### 4.3 实现方案

#### 核心算法

```python
def to_dfa(self):
    """子集构造算法：将NFA转换为等价的DFA"""
    dfa_start_state = frozenset({self.start_state})
    dfa_states = set()
    dfa_transitions = {}
    dfa_accept_states = set()
    
    unprocessed = [dfa_start_state]
    processed = set()
    
    while unprocessed:
        current_dfa_state = unprocessed.pop(0)
        
        if current_dfa_state in processed:
            continue
        
        processed.add(current_dfa_state)
        dfa_states.add(current_dfa_state)
        
        # 检查是否为接受状态
        if current_dfa_state & self.accept_states:
            dfa_accept_states.add(current_dfa_state)
        
        # 初始化转移
        if current_dfa_state not in dfa_transitions:
            dfa_transitions[current_dfa_state] = {}
        
        # 对每个输入符号计算转移
        for symbol in self.alphabet:
            next_nfa_states = self._move(set(current_dfa_state), symbol)
            next_dfa_state = frozenset(next_nfa_states)
            
            dfa_transitions[current_dfa_state][symbol] = next_dfa_state
            
            if next_dfa_state and next_dfa_state not in processed:
                unprocessed.append(next_dfa_state)
                dfa_states.add(next_dfa_state)
    
    return DFA(dfa_states, self.alphabet, dfa_transitions, 
               dfa_start_state, dfa_accept_states)
```

**算法复杂度**：
- 时间复杂度：O(2^n × |Σ|)，其中n是NFA状态数
- 空间复杂度：O(2^n)

### 4.4 运行结果

```
======================================================================
第四题：子集构造算法（NFA转DFA）
======================================================================

NFA定义：
  状态集合 Q = {1, 2, 3, 4, 5, 6, 7, 8, 9}
  字母表 Σ = {'r', 'b'}
  起始状态 q0 = 1
  接受状态 F = {9}

  转移函数 δ:
    δ(1, b) = {5}
    δ(1, r) = {2, 4}
    δ(2, b) = {1, 3, 5}
    δ(2, r) = {4, 6}
    ... (省略部分输出)

======================================================================
执行子集构造算法...
======================================================================

DFA定义：
  状态数量: 7
  起始状态: {1}
  接受状态数量: 2

  接受状态:
    {1, 3, 5, 7, 9}
    {1, 3, 7, 9}

  DFA转移表:
  ----------------------------------------------------------------------
  状态                             | r                  | b                 
  ----------------------------------------------------------------------
  → {1}                          | {2, 4}             | {5}               
  {5}                            | {2, 4, 6, 8}       | {1, 3, 7, 9}      
  {2, 4}                         | {2, 4, 6, 8}       | {1, 3, 5, 7}      
  {1, 3, 5, 7}                   | {2, 4, 6, 8}       | {1, 3, 5, 7, 9}   
  * {1, 3, 7, 9}                 | {2, 4, 6, 8}       | {5}               
  {2, 4, 6, 8}                   | {2, 4, 6, 8}       | {1, 3, 5, 7, 9}   
  * {1, 3, 5, 7, 9}              | {2, 4, 6, 8}       | {1, 3, 5, 7, 9}   
  ----------------------------------------------------------------------
  说明: → 表示起始状态, * 表示接受状态

======================================================================
测试字符串（验证NFA和DFA等价性）
======================================================================

  字符串        | NFA结果      | DFA结果      | 一致性
  --------------------------------------------------
  r          | 拒绝         | 拒绝         | ✓
  b          | 拒绝         | 拒绝         | ✓
  rr         | 拒绝         | 拒绝         | ✓
  rb         | 拒绝         | 拒绝         | ✓
  br         | 拒绝         | 拒绝         | ✓
  bb         | 接受         | 接受         | ✓
  rrb        | 接受         | 接受         | ✓
  rbr        | 拒绝         | 拒绝         | ✓
```

### 4.5 结果分析

✅ **转换正确性**：
- NFA有9个状态，生成的DFA有7个状态
- 起始状态为{1}，对应NFA的起始状态
- 2个接受状态，都包含NFA的接受状态9

✅ **等价性验证**：
- 所有测试字符串在NFA和DFA上的结果完全一致 ✓
- 这证明了转换后的DFA与原NFA等价

✅ **状态数量分析**：
- 理论最大状态数：2^9 = 512
- 实际生成状态数：7
- 说明大部分状态组合是不可达的，算法高效地只生成了可达状态

✅ **转移表完整性**：
- 每个DFA状态对于每个输入符号都有明确的转移
- 转移表是完全定义的（没有未定义的转移）

### 4.6 算法优化

本实现采用了以下优化策略：
1. **使用frozenset**：使DFA状态可哈希，便于存储和查找
2. **避免重复处理**：使用processed集合记录已处理的状态
3. **按需生成**：只生成从起始状态可达的状态
4. **队列处理**：使用BFS方式遍历状态空间

---

## 5. 可复用组件设计

### 5.1 Language类（language.py）

**功能**：提供形式语言的基本操作

**主要方法**：
- `concatenate(other)`: 语言串接
- `star(max_length)`: 上界为T的星操作
- `union(other)`: 语言并集
- `__str__()`: 格式化输出

**设计特点**：
- 使用set存储字符串，自动去重
- 支持空字符串（用ε表示）
- 提供友好的字符串表示

**应用场景**：
- 形式语言理论的基本操作
- 正则表达式的语义实现
- 语言的代数运算

### 5.2 DFA类（dfa.py）

**功能**：实现确定性有限自动机

**主要方法**：
- `delta(q, a)`: 单步转移函数
- `extended_delta(q, s, verbose)`: 扩展转移函数
- `accepts(s)`: 判断字符串是否被接受

**设计特点**：
- 完整的错误检查和异常处理
- 支持verbose模式打印转移过程
- 清晰的状态转移逻辑

**应用场景**：
- 词法分析器的实现
- 模式匹配
- 字符串验证

### 5.3 NFA类（nfa.py）

**功能**：实现非确定性有限自动机

**主要方法**：
- `accepts(s)`: 判断字符串是否被接受
- `to_dfa()`: 子集构造算法
- `_move(states, symbol)`: 计算状态集合的转移

**设计特点**：
- 支持非确定性转移（一对多）
- 实现了完整的子集构造算法
- 可以转换为等价的DFA

**应用场景**：
- 正则表达式到自动机的转换
- 模式匹配的中间表示
- 自动机理论的教学演示

### 5.4 模块间关系

```
Language类
  ↓ 独立使用
  
DFA类 ←── NFA类
  ↑        ↓
  └── to_dfa()
```

- Language类独立于自动机类
- NFA可以转换为DFA
- 所有类都可以独立使用

---

## 6. 代码质量

### 6.1 代码规范

✅ **命名规范**：
- 类名使用大驼峰（PascalCase）
- 函数名使用小写下划线（snake_case）
- 常量使用大写下划线

✅ **注释规范**：
- 每个类和函数都有文档字符串
- 关键算法有详细的行内注释
- 使用中文注释，便于理解

✅ **代码结构**：
- 模块化设计，职责清晰
- 函数长度适中，易于理解
- 避免代码重复

### 6.2 错误处理

所有关键函数都包含错误检查：

```python
# DFA转移函数的错误检查
if q not in self.states:
    raise ValueError(f"状态 {q} 不在状态集合中")
if a not in self.alphabet:
    raise ValueError(f"字符 {a} 不在字母表中")
```

### 6.3 测试覆盖

每道题都包含：
- ✅ 基本功能测试
- ✅ 边界情况测试
- ✅ 额外的验证测试
- ✅ 结果正确性验证

---

## 7. 实验总结

### 7.1 主要成果

1. ✨ **完整实现**：成功完成所有四道题目，所有测试通过
2. ✨ **模块化设计**：创建了可复用的Language、DFA、NFA类
3. ✨ **代码质量**：代码结构清晰，注释详细，符合规范
4. ✨ **算法正确**：所有算法实现正确，结果经过验证
5. ✨ **可扩展性**：组件可在后续课程中继续使用

### 7.2 技术亮点

| 亮点 | 说明 |
|------|------|
| 模块化设计 | 将可复用组件抽象为独立的类 |
| 算法优化 | 子集构造算法只生成可达状态 |
| 错误处理 | 完整的输入验证和异常处理 |
| 可视化输出 | 清晰的格式化输出和状态转移打印 |
| 测试完整 | 每道题都有详细的测试和验证 |

### 7.3 学习收获

通过本次实验，我深入理解了：

1. **形式语言理论**：
   - 语言的串接和星操作的定义和实现
   - 这些操作在正则表达式中的应用

2. **有限自动机**：
   - DFA和NFA的区别和联系
   - 状态转移的实现方法
   - 字符串接受判断的算法

3. **子集构造算法**：
   - NFA到DFA转换的原理
   - 状态空间的指数增长问题
   - 可达状态的优化策略

4. **软件工程**：
   - 模块化设计的重要性
   - 代码复用的价值
   - 良好的代码规范和注释

5. **算法实现**：
   - 理论到代码的转换
   - 数据结构的选择（set, frozenset, dict）
   - 算法复杂度的分析

### 7.4 实验难点与解决

| 难点 | 解决方案 |
|------|----------|
| 星操作的实现 | 使用层次化生成，逐层构建 |
| DFA状态转移的打印 | 在extended_delta中添加verbose参数 |
| NFA状态集合的表示 | 使用frozenset使其可哈希 |
| 子集构造的效率 | 只生成可达状态，避免指数爆炸 |

### 7.5 可能的改进

1. **性能优化**：
   - 对大规模数据使用更高效的数据结构
   - 实现状态最小化算法

2. **功能扩展**：
   - 支持ε-NFA（带空转移的NFA）
   - 实现正则表达式到NFA的转换
   - 添加自动机的可视化功能

3. **测试增强**：
   - 添加单元测试框架
   - 增加性能测试
   - 添加随机测试用例生成

---

## 8. 运行说明

### 8.1 环境要求

```bash
# Python版本
Python 3.7+

# 依赖包
numpy  # 用于数据处理（可选）
```

### 8.2 运行方式

#### 使用conda环境（推荐）

```bash
# 激活ml环境
conda activate ml

# 运行各题
python 作业一/question1.py
python 作业一/question2.py
python 作业一/question3.py
python 作业一/question4.py
```

#### 直接运行

```bash
cd 作业一
python question1.py
python question2.py
python question3.py
python question4.py
```

### 8.3 预期输出

每个程序都会输出：
- 问题描述和输入数据
- 计算过程（如状态转移）
- 最终结果
- 结果验证信息

运行时间：每个程序约1-2秒

---

## 9. 附录

### 9.1 完整代码统计

| 文件 | 行数 | 说明 |
|------|------|------|
| common/__init__.py | 10 | 包初始化 |
| common/language.py | 110 | Language类实现 |
| common/dfa.py | 100 | DFA类实现 |
| common/nfa.py | 130 | NFA类实现 |
| question1.py | 50 | 第一题实现 |
| question2.py | 60 | 第二题实现 |
| question3.py | 120 | 第三题实现 |
| question4.py | 150 | 第四题实现 |
| **总计** | **730** | **代码总行数** |

### 9.2 测试结果汇总

| 题目 | 测试用例 | 结果 | 状态 |
|------|----------|------|------|
| 第一题 | L1={a,ab,abc}, L2={x,xy,xyz} | 9个串接结果 | ✅ 通过 |
| 第二题 | L={0,1}, T=3 | 15个字符串 | ✅ 通过 |
| 第三题 | Sp="0101", Sn="011" | 正确接受/拒绝 | ✅ 通过 |
| 第四题 | 9状态NFA | 7状态DFA | ✅ 通过 |

### 9.3 参考资料

1. 课程课件：lec1-dfa, lec2-nfa
2. 教材：《Introduction to the Theory of Computation》
3. Python官方文档：https://docs.python.org/3/

---

## 声明

**本实验报告及相关代码仅用于课程学习，请勿分发。**

**完成日期**: 2025年10月30日  
---
